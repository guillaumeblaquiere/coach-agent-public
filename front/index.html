<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Plan</title>
    <style>
        body {
            font-family: sans-serif;
            margin-right: 350px; /* Space for the chat pane */
            position: relative; /* For chat pane positioning context if needed */
        }

        .date-controls {
            text-align: center;
            margin: 20px 0;
        }

        .date-controls button {
            padding: 5px 10px;
            margin: 0 10px;
        }

        #date-display {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
        }

        .accordion {
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #f0f0f0;
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .accordion-header h3 {
            margin: 0;
        }

        .accordion-content {
            padding: 10px;
            display: none; /* Hidden by default */
        }

        .accordion-content.show {
            display: block;
        }

        .drill {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .drill-name {
            font-weight: bold;
        }

        .drill-desc {
            font-size: 0.9em;
            color: #333;
            margin-top: 3px;
        }

        .drill-controls {
            margin-top: 5px;
            display: flex;
            align-items: center;
        }

        .drill-controls button {
            padding: 3px 8px;
            margin: 0 5px;
        }

        .drill-repetition {
            width: 50px;
            padding: 3px;
            margin: 0 5px;
            text-align: center;
        }

        /* NOUVEAU STYLE POUR L'INPUT DE NOTE */
        .drill-note-input {
            flex-grow: 1;
            padding: 3px;
            margin-left: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .accordion-header .category-reps {
            font-size: 0.9em;
            color: #555;
        }

        .read-only {
            pointer-events: none;
            opacity: 0.7;
        }

        /* Chat Pane Styles */
        #chat-pane {
            position: fixed;
            right: 0;
            top: 0;
            width: 350px;
            height: 100%;
            border-left: 1px solid #ccc;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            z-index: 1000; /* Ensure it's on top */
        }

        #chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .chat-message {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 18px;
            max-width: 90%; /* Adjusted for better fit */
            word-wrap: break-word;
        }

        .chat-message.user {
            background-color: #dcf8c6;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .chat-message.audio {
            background-color: #e0e0e0; /* Different background for audio */
            align-self: flex-end; /* Assuming user recorded audio */
        }

        .chat-message.audio audio {
            display: block;
            margin-top: 5px;
            max-width: 100%;
            height: 40px; /* Consistent height for audio player */
        }


        #chat-input-area {
            display: flex;
            padding: 10px;
            border-top: 1px solid #ccc;
            background-color: #fff;
            align-items: center;
        }

        #chat-input-area {
            display: flex;
            flex-direction: column; /* Chang√© pour empiler les √©l√©ments verticalement */
            padding: 10px;
            border-top: 1px solid #ccc;
            background-color: #fff;
            /* align-items: center; */ /* Peut √™tre ajust√© ou supprim√© selon le besoin */
        }

        .message-controls-row {
            display: flex;
            width: 100%;
            align-items: center;
            margin-top: 5px; /* Ajoute un petit espace si vad-controls a une marge en bas */
        }

        #chat-message-input {
            flex-grow: 1; /* Allow input to take available space */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 18px;
            margin-right: 5px;
        }

        #chat-send-button, #chat-mic-button, #chat-delete-session-button { /* Ajout de #chat-delete-session-button */
            padding: 0;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            margin-left: 5px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }

        #chat-mic-button.muted {
            background-color: #6c757d; /* Grey when muted */
        }

        #chat-mic-button.recording {
            background-color: #dc3545; /* Red when recording */
        }


        #chat-delete-session-button { /* Style sp√©cifique si besoin, par ex. couleur diff√©rente */
            background-color: #dc3545; /* Rouge pour une action de suppression */
        }
    </style>
</head>
<body>
<div class="date-controls">
    <button id="prev-day">&lt;</button>
    <span id="date-display"></span>
    <button id="next-day">&gt;</button>
    <input type="date" id="date-picker" style="display: none;">
</div>

<div id="plan-container">
    <!-- Training plan content will be loaded here -->
</div>

<!-- Chat Pane -->
<div id="chat-pane">
    <div id="chat-history">
        <!-- Messages will be appended here -->
    </div>
    <div id="chat-input-area">
        <div id="vad-controls" style="display: flex; flex-direction: column; margin-bottom: 5px; width: 100%;">
            <label for="vad-threshold-slider" style="font-size: 0.8em; margin-bottom: 2px;">Seuil VAD:</label>
            <!-- Label simplifi√© -->
            <div style="display: flex; align-items: center;">
                <input type="range" id="vad-threshold-slider" min="1" max="80" step="1" value="15"
                       style="flex-grow: 1; margin-right: 5px;">
                <span id="vad-threshold-value" style="font-size: 0.8em; min-width: 25px; text-align: right;">15</span>
            </div>
            <progress id="mic-gain-meter" value="0" max="255"
                      style="width: 100%; height: 5px; margin-top: 2px;"></progress>
        </div>
        <div class="message-controls-row">
            <input type="text" id="chat-message-input" placeholder="Type a message...">
            <button id="chat-send-button" title="Send">‚ûî</button>
            <button id="chat-mic-button" title="Toggle Microphone">üé§</button>
            <button id="chat-delete-session-button" title="Delete Session">üóëÔ∏è</button> <!-- NOUVEAU BOUTON -->
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Existing Training Plan JavaScript
        const dateDisplay = document.getElementById('date-display');
        const datePicker = document.getElementById('date-picker');
        const prevDayButton = document.getElementById('prev-day');
        const nextDayButton = document.getElementById('next-day');
        const planContainer = document.getElementById('plan-container');
        // For local testing. Removed for the deployment (see dockerfile)
        const coachBackendURL = "http://localhost:8080"
        const coachAgentURL = "http://localhost:8081"

        let currentDate = new Date();
        let isToday = true;
        let currentPlanTemplate = null; // To store the plan structure (categories, drills)
        let currentDailyPlanData = null; // To store daily achievements (repetitions, notes)

        function formatDate(date) {
            return date.toISOString().slice(0, 10);
        }

        function updateDateDisplay() {
            dateDisplay.textContent = formatDate(currentDate);
            isToday = formatDate(currentDate) === formatDate(new Date());
            planContainer.classList.toggle('read-only', !isToday);
        }

        async function loadPlanTemplate() {
            if (currentPlanTemplate) {
                return Promise.resolve(currentPlanTemplate);
            }
            try {
                const response = await fetch(coachBackendURL + '/api/v1/plan-templates/default');
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Template fetch failed: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                currentPlanTemplate = await response.json();
                return currentPlanTemplate;
            } catch (error) {
                console.error('Error loading plan template:', error);
                planContainer.innerHTML = `<p>Error loading plan structure: ${error.message}</p>`;
                throw error;
            }
        }

        async function loadDailyPlanData(dateStr) {
            const endpoint = `/api/v1/daily-plans/${dateStr === formatDate(new Date()) ? 'today' : dateStr}`;
            try {
                let response = await fetch(coachBackendURL + endpoint);
                if (response.status === 404 && dateStr === formatDate(new Date())) {
                    const initResponse = await fetch(coachBackendURL + '/api/v1/daily-plans/initiate', {method: 'POST'});
                    if (!initResponse.ok) {
                        const errorData = await initResponse.json().catch(() => ({}));
                        throw new Error(`Failed to initiate plan: ${initResponse.statusText} (${errorData.error || 'Unknown error'})`);
                    }
                    currentDailyPlanData = await initResponse.json();
                } else if (response.status === 404) { // Not found for a past date
                    currentDailyPlanData = null; // No data exists, will display template with 0 reps
                } else if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to load daily plan: ${response.statusText} (${errorData.error || 'Plan not found'})`);
                } else {
                    currentDailyPlanData = await response.json();
                }
                return currentDailyPlanData;
            } catch (error) {
                console.error('Error loading daily plan data:', error);
                planContainer.innerHTML = `<p>Error loading plan data: ${error.message}</p>`;
                currentDailyPlanData = null;
                throw error;
            }
        }

        async function loadPlan() {
            const dateStr = formatDate(currentDate);
            planContainer.innerHTML = '<p>Loading plan...</p>';
            updateDateDisplay(); // Update read-only status and date display early

            try {
                await loadPlanTemplate();
                await loadDailyPlanData(dateStr);

                if (currentPlanTemplate) { // Always try to display template structure
                    displayPlan(currentPlanTemplate, currentDailyPlanData);
                } else {
                    // Error message for template loading failure is already set by loadPlanTemplate
                }
            } catch (error) {
                // Errors are logged by sub-functions, planContainer might have specific error messages.
                console.error('Error in loadPlan orchestration:', error);
                if (!planContainer.innerHTML.includes("Error") && !planContainer.innerHTML.includes("Loading")) {
                    planContainer.innerHTML = `<p>An unexpected error occurred.</p>`;
                }
            }
        }

        function displayPlan(planTemplate, dailyPlanData) {
            planContainer.innerHTML = '';
            if (!planTemplate || !planTemplate.categories) {
                planContainer.innerHTML = '<p>No plan structure (template) available to display.</p>';
                return;
            }

            for (const categoryId in planTemplate.categories) {
                const category = planTemplate.categories[categoryId];
                const categoryElement = document.createElement('div');
                categoryElement.classList.add('accordion');
                categoryElement.dataset.categoryId = categoryId;

                const header = document.createElement('div');
                header.classList.add('accordion-header');
                header.innerHTML = `<h3>${category.name}</h3>`;

                const categoryRepsDisplay = document.createElement('span');
                categoryRepsDisplay.classList.add('category-reps');
                header.appendChild(categoryRepsDisplay);

                const catButtons = document.createElement('div');
                const catIncButton = document.createElement('button');
                catIncButton.textContent = '+';
                catIncButton.onclick = (e) => {
                    e.stopPropagation();
                    adjustCategoryReps(categoryId, 1);
                };
                const catDecButton = document.createElement('button');
                catDecButton.textContent = '-';
                catDecButton.onclick = (e) => {
                    e.stopPropagation();
                    adjustCategoryReps(categoryId, -1);
                };
                catButtons.append(catIncButton, catDecButton);
                header.appendChild(catButtons);

                categoryElement.appendChild(header);

                const content = document.createElement('div');
                content.classList.add('accordion-content', 'show'); // Default to show

                let minRepsInCategory = Infinity;
                let hasDrillsInCat = false;

                if (category.drills) {
                    for (const drillId in category.drills) {
                        hasDrillsInCat = true;
                        const drill = category.drills[drillId];
                        const drillElement = document.createElement('div');
                        drillElement.classList.add('drill');
                        drillElement.dataset.drillId = drillId;
                        drillElement.dataset.categoryId = categoryId;

                        const drillName = document.createElement('div');
                        drillName.classList.add('drill-name');
                        drillName.textContent = drill.name;
                        drillElement.appendChild(drillName);

                        if (drill.description) {
                            const drillDesc = document.createElement('div');
                            drillDesc.classList.add('drill-desc');
                            drillDesc.textContent = drill.description;
                            drillElement.appendChild(drillDesc);
                        }

                        const drillControls = document.createElement('div');
                        drillControls.classList.add('drill-controls');
                        const decButton = document.createElement('button');
                        decButton.textContent = '-';
                        decButton.onclick = () => adjustDrillReps(categoryId, drillId, -1);

                        const incButton = document.createElement('button');
                        incButton.textContent = '+';
                        incButton.onclick = () => adjustDrillReps(categoryId, drillId, 1);

                        const repsDisplay = document.createElement('span');
                        repsDisplay.classList.add('drill-repetition');

                        let currentRepetition = 0;
                        let currentNote = "";
                        // dailyPlanData might be null if no plan exists for a past date
                        if (dailyPlanData && dailyPlanData.repetitions &&
                            dailyPlanData.repetitions[categoryId] &&
                            dailyPlanData.repetitions[categoryId][drillId]) {
                            const achievement = dailyPlanData.repetitions[categoryId][drillId];
                            currentRepetition = achievement.repetition || 0;
                            currentNote = achievement.note || "";
                        }
                        repsDisplay.textContent = currentRepetition;
                        minRepsInCategory = Math.min(minRepsInCategory, currentRepetition);

                        // CHAMP NOTE AJOUT√â ICI
                        const noteInput = document.createElement('input');
                        noteInput.type = 'text';
                        noteInput.classList.add('drill-note-input');
                        noteInput.placeholder = 'Notes...';
                        noteInput.value = currentNote;
                        // Fin ajout champ note

                        drillControls.append(decButton, repsDisplay, incButton, noteInput); // noteInput ajout√© ici
                        drillElement.appendChild(drillControls);
                        content.appendChild(drillElement);
                    }
                }
                categoryRepsDisplay.textContent = `(Min Reps: ${hasDrillsInCat && minRepsInCategory !== Infinity ? minRepsInCategory : 0})`;
                categoryElement.appendChild(content);
                planContainer.appendChild(categoryElement);

                header.addEventListener('click', (e) => {
                    // Prevent accordion toggle if a button inside header was clicked
                    if (e.target.closest('button')) return;
                    content.classList.toggle('show');
                });
            }
            updateDateDisplay(); // Applies read-only if necessary
        }

        function ensureDailyPlanDataInitialized() {
            if (!currentDailyPlanData) {
                // Initialize a basic structure if today and no data (e.g., after initiation failed or for a new interaction)
                if (isToday) {
                    currentDailyPlanData = {
                        id: `${formatDate(currentDate)}-temp`, // Temporary ID
                        templateId: currentPlanTemplate?.id || "default",
                        date: formatDate(currentDate),
                        repetitions: {},
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                } else {
                    console.warn("Cannot modify: No existing daily plan data for this past date.");
                    addMessageToChat("Cannot modify plan for a past date without existing data.", "system-warning");
                    return false;
                }
            }
            if (!currentDailyPlanData.repetitions) {
                currentDailyPlanData.repetitions = {};
            }
            return true;
        }


        function adjustDrillReps(categoryId, drillId, adjustment) {
            if (!currentPlanTemplate || !currentPlanTemplate.categories[categoryId]?.drills[drillId]) {
                console.warn("Drill definition not found in template.");
                return;
            }
            if (!isToday) { // Only allow edits for today
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }

            if (!ensureDailyPlanDataInitialized()) return;


            if (!currentDailyPlanData.repetitions[categoryId]) {
                currentDailyPlanData.repetitions[categoryId] = {};
            }
            if (!currentDailyPlanData.repetitions[categoryId][drillId]) {
                currentDailyPlanData.repetitions[categoryId][drillId] = {repetition: 0, note: ""};
            }

            let achievement = currentDailyPlanData.repetitions[categoryId][drillId];
            let newReps = (achievement.repetition || 0) + adjustment;
            if (newReps < 0) newReps = 0;

            // R√©cup√©rer la note actuelle depuis le champ input dans le DOM
            const drillElement = planContainer.querySelector(`.drill[data-category-id="${categoryId}"][data-drill-id="${drillId}"]`);
            let noteFromInput = achievement.note; // Valeur par d√©faut
            if (drillElement) {
                const noteInputElement = drillElement.querySelector('.drill-note-input');
                if (noteInputElement) {
                    noteFromInput = noteInputElement.value;
                }
            }

            achievement.repetition = newReps;
            achievement.note = noteFromInput; // Mettre √† jour la note dans les donn√©es locales

            displayPlan(currentPlanTemplate, currentDailyPlanData); // Optimistic UI update (re-renders with new note)

            saveDrillUpdate(categoryId, drillId, newReps, achievement.note); // Envoyer la note mise √† jour
        }

        function adjustCategoryReps(categoryId, adjustment) {
            if (!currentPlanTemplate || !currentPlanTemplate.categories[categoryId]?.drills) {
                console.warn("Category or drills not found in template.");
                return;
            }
            if (!isToday) {
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }

            if (!ensureDailyPlanDataInitialized()) return;

            const categoryDrills = currentPlanTemplate.categories[categoryId].drills;
            const drillsToUpdate = {}; // Chang√© de [] √† {} pour correspondre au payload attendu

            if (!currentDailyPlanData.repetitions[categoryId]) {
                currentDailyPlanData.repetitions[categoryId] = {};
            }
            // Initialiser drillsToUpdate[categoryId] si ce n'est pas d√©j√† fait
            if (!drillsToUpdate[categoryId]) {
                drillsToUpdate[categoryId] = {};
            }

            for (const drillId in categoryDrills) {
                if (!currentDailyPlanData.repetitions[categoryId][drillId]) {
                    currentDailyPlanData.repetitions[categoryId][drillId] = {repetition: 0, note: ""};
                }
                let achievement = currentDailyPlanData.repetitions[categoryId][drillId];
                let newReps = (achievement.repetition || 0) + adjustment;
                if (newReps < 0) newReps = 0;

                // R√©cup√©rer la note actuelle depuis le champ input dans le DOM pour ce drill
                const drillElement = planContainer.querySelector(`.drill[data-category-id="${categoryId}"][data-drill-id="${drillId}"]`);
                let noteFromInput = achievement.note; // Valeur par d√©faut
                if (drillElement) {
                    const noteInputElement = drillElement.querySelector('.drill-note-input');
                    if (noteInputElement) {
                        noteFromInput = noteInputElement.value;
                    }
                }

                achievement.repetition = newReps; // Update local data
                achievement.note = noteFromInput; // Update local note data

                // Prepare for backend update
                drillsToUpdate[categoryId][drillId] = {repetition: newReps, note: achievement.note};
            }

            displayPlan(currentPlanTemplate, currentDailyPlanData); // Optimistic UI update

            // Now, call a function to save all these updates to the backend
            if (Object.keys(drillsToUpdate[categoryId]).length > 0) { // V√©rifier s'il y a des drills √† mettre √† jour dans cette cat√©gorie
                // Le payload pour saveMultipleDrillUpdates attend un objet o√π les cl√©s sont les categoryId
                const payloadForBackend = {[categoryId]: drillsToUpdate[categoryId]};
                saveMultipleDrillUpdates(payloadForBackend);
            }
        }

        async function saveDrillUpdate(categoryId, drillId, newReps, note) {
            if (!isToday) {
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }
            if (!ensureDailyPlanDataInitialized()) return;


            const payload = {
                repetitions: {
                    [categoryId]: {
                        [drillId]: {
                            repetition: newReps,
                            note: note || "" // Ensure note is always a string
                        }
                    }
                }
            };

            try {
                const response = await fetch(coachBackendURL + '/api/v1/daily-plans/today', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-User-Email': userEmail
                    },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to save drill update: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                const updatedPlanFromServer = await response.json();
                currentDailyPlanData = updatedPlanFromServer;
                displayPlan(currentPlanTemplate, currentDailyPlanData); // Re-render with authoritative data
                addMessageToChat("Plan updated successfully.", "system-success");

            } catch (error) {
                console.error('Error saving drill update:', error);
                addMessageToChat(`Error saving update: ${error.message}`, 'system-error');
            }
        }

        async function saveMultipleDrillUpdates(repetitionsPayload) {
            // repetitionsPayload is expected to be like: { categoryId1: { drillId1: {repetition: X, note: Y}, ... }, ... }
            if (!isToday || Object.keys(repetitionsPayload).length === 0) {
                if (Object.keys(repetitionsPayload).length === 0) console.log("No updates to send for category adjustment.");
                return;
            }
            if (!ensureDailyPlanDataInitialized()) return;


            const payload = {
                repetitions: repetitionsPayload
            };

            try {
                const response = await fetch(coachBackendURL + '/api/v1/daily-plans/today', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json',
                    'X-User-Email': userEmail},
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to save multiple drill updates: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                const updatedPlanFromServer = await response.json();
                currentDailyPlanData = updatedPlanFromServer;
                displayPlan(currentPlanTemplate, currentDailyPlanData);
                addMessageToChat("Category repetitions updated successfully.", "system-success");

            } catch (error) {
                console.error('Error saving multiple drill updates:', error);
                addMessageToChat(`Error saving category update: ${error.message}`, 'system-error');
            }
        }

        // Event listeners for date controls
        dateDisplay.addEventListener('click', () => {
            datePicker.style.display = 'block';
            datePicker.value = formatDate(currentDate);
            datePicker.focus();
        });

        datePicker.addEventListener('blur', () => {
            setTimeout(() => {
                if (document.activeElement !== datePicker) {
                    datePicker.style.display = 'none';
                }
            }, 100);
        });

        datePicker.addEventListener('change', () => {
            currentDate = new Date(datePicker.value + 'T00:00:00');
            datePicker.style.display = 'none';
            loadPlan();
        });

        prevDayButton.addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() - 1);
            loadPlan();
        });

        nextDayButton.addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() + 1);
            loadPlan();
        });

        // Initial load for training plan
        loadPlan();

        // --- Chat Pane JavaScript ---
        const chatHistory = document.getElementById('chat-history');
        const chatMessageInput = document.getElementById('chat-message-input');
        const chatSendButton = document.getElementById('chat-send-button');
        const chatMicButton = document.getElementById('chat-mic-button');
        const chatDeleteSessionButton = document.getElementById('chat-delete-session-button');
        const vadThresholdSlider = document.getElementById('vad-threshold-slider');
        const vadThresholdValueDisplay = document.getElementById('vad-threshold-value');
        const micGainMeter = document.getElementById('mic-gain-meter');

        let mediaRecorder;
        let audioChunks = [];
        let isMicMuted = true; // Start muted
        let audioContext;
        let analyser;
        let microphoneStream;
        let vadInterval;
        const MIN_RECORDING_DURATION_MS = 300;
        const VAD_CHECK_INTERVAL = 100;
        let VAD_THRESHOLD = parseFloat(vadThresholdSlider.value);
        const SILENCE_DURATION_THRESHOLD = 500;
        let silenceStartTime = 0;
        let hasDetectedSpeechInSegment = false;

        vadThresholdSlider.addEventListener('input', () => {
            VAD_THRESHOLD = parseFloat(vadThresholdSlider.value);
            vadThresholdValueDisplay.textContent = VAD_THRESHOLD.toFixed(0);
        });

        function addMessageToChat(text, type = 'user', isAudio = false, audioBlobUrl = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message', type);

            if (type === 'system-error') messageElement.style.color = 'red';
            if (type === 'system-success') messageElement.style.color = 'green';
            if (type === 'system-info') messageElement.style.color = 'blue';


            if (isAudio && audioBlobUrl) {
                messageElement.classList.add('audio');
                const audioElement = document.createElement('audio');
                audioElement.controls = true;
                audioElement.src = audioBlobUrl;
                messageElement.appendChild(audioElement);
            } else {
                messageElement.textContent = text;
            }

            chatHistory.appendChild(messageElement);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            if (type !== 'user' && type !== 'received') {
                const audioElement = messageElement.querySelector('audio');
                if (audioElement) {
                    // Autoplay for system responses with audio might be desired or not.
                }
            } else if (type === 'received') { // Agent's response
                const audioElement = messageElement.querySelector('audio');
                if (audioElement) {
                    audioElement.play().catch(e => console.warn("Audio playback failed for received message:", e));
                }
            }
        }

        chatSendButton.addEventListener('click', () => {
            const messageText = chatMessageInput.value.trim();
            if (messageText) {
                addMessageToChat(messageText, 'user');
                chatMessageInput.value = '';
                sendChatMessage({text: messageText});
            }
        });

        chatMessageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                chatSendButton.click();
            }
        });

        async function setupMicrophone() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                addMessageToChat("getUserMedia not supported on your browser!", "system-error");
                return;
            }
            try {
                microphoneStream = await navigator.mediaDevices.getUserMedia({audio: true});
                isMicMuted = false;
                chatMicButton.classList.remove('muted');
                chatMicButton.title = "Mute Microphone (Currently Unmuted)";

                hasDetectedSpeechInSegment = false;
                audioChunks = [];

                mediaRecorder = new MediaRecorder(microphoneStream);
                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    chatMicButton.classList.remove('recording');
                    chatMicButton.title = isMicMuted ? "Toggle Microphone (Currently Muted)" : "Mute Microphone (Currently Unmuted)";

                    if (hasDetectedSpeechInSegment && audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, {type: 'audio/webm;codecs=opus'});
                        audioChunks = [];
                        hasDetectedSpeechInSegment = false;

                        try {
                            const tempAudio = document.createElement('audio');
                            const tempUrl = URL.createObjectURL(audioBlob);
                            tempAudio.src = tempUrl;
                            tempAudio.onloadedmetadata = () => {
                                URL.revokeObjectURL(tempUrl);
                                if (tempAudio.duration * 1000 >= MIN_RECORDING_DURATION_MS) {
                                    const audioUrlForDisplay = URL.createObjectURL(audioBlob);
                                    addMessageToChat(null, 'user', true, audioUrlForDisplay);
                                    sendChatMessage({audioBlob: audioBlob});
                                    console.log(`Audio sent, duration: ${(tempAudio.duration * 1000).toFixed(0)}ms`);
                                } else {
                                    console.log(`Audio discarded, duration too short: ${(tempAudio.duration * 1000).toFixed(0)}ms`);
                                    addMessageToChat("Recording too short, discarded.", "system-info");
                                }
                            };
                            tempAudio.onerror = () => {
                                URL.revokeObjectURL(tempUrl);
                                console.warn("Could not determine audio duration, sending anyway.");
                                const audioUrlForDisplay = URL.createObjectURL(audioBlob);
                                addMessageToChat(null, 'user', true, audioUrlForDisplay);
                                sendChatMessage({audioBlob: audioBlob});
                            };
                        } catch (e) {
                            console.error("Error in audio duration check or sending:", e);
                            const audioUrlForDisplay = URL.createObjectURL(audioBlob);
                            addMessageToChat(null, 'user', true, audioUrlForDisplay);
                            sendChatMessage({audioBlob: audioBlob});
                        }
                    } else {
                        console.log("No speech detected or audio chunks empty, not sending.");
                        if (audioChunks.length > 0) audioChunks = [];
                        hasDetectedSpeechInSegment = false;
                    }

                    if (isMicMuted && vadInterval) {
                        clearInterval(vadInterval);
                        vadInterval = null;
                        if (audioContext && audioContext.state !== 'closed') audioContext.close();
                    }
                };

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(microphoneStream);
                source.connect(analyser);
                analyser.fftSize = 512;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);

                if (vadInterval) clearInterval(vadInterval);

                vadInterval = setInterval(() => {
                    if (isMicMuted || !mediaRecorder || !analyser) {
                        micGainMeter.value = 0;
                        if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
                        if (vadInterval) clearInterval(vadInterval);
                        vadInterval = null;
                        if (audioContext && audioContext.state !== 'closed') audioContext.close();
                        return;
                    }

                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const averageVolume = sum / dataArray.length;
                    micGainMeter.value = averageVolume;

                    if (averageVolume > VAD_THRESHOLD) {
                        if (mediaRecorder.state === "inactive") {
                            audioChunks = [];
                            mediaRecorder.start(VAD_CHECK_INTERVAL);
                            chatMicButton.classList.add('recording');
                            chatMicButton.title = "Recording... (Click to Mute)";
                            hasDetectedSpeechInSegment = true;
                        }
                        silenceStartTime = 0;
                    } else {
                        if (mediaRecorder.state === "recording") {
                            if (silenceStartTime === 0) {
                                silenceStartTime = Date.now();
                            } else if (Date.now() - silenceStartTime > SILENCE_DURATION_THRESHOLD) {
                                mediaRecorder.stop();
                                silenceStartTime = 0;
                            }
                        }
                    }
                }, VAD_CHECK_INTERVAL);

            } catch (err) {
                console.error("Error accessing microphone:", err);
                addMessageToChat(`Microphone access error: ${err.message}`, "system-error");
                stopMicrophone(true);
            }
        }

        function stopMicrophone(isError = false) {
            isMicMuted = true;

            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            mediaRecorder = null;


            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
            }

            if (vadInterval) {
                clearInterval(vadInterval);
                vadInterval = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close().catch(e => console.warn("Error closing audio context:", e));
                audioContext = null;
            }

            analyser = null;
            audioChunks = [];
            hasDetectedSpeechInSegment = false;
            silenceStartTime = 0;
            micGainMeter.value = 0;

            chatMicButton.classList.add('muted');
            chatMicButton.classList.remove('recording');
            chatMicButton.title = "Toggle Microphone (Currently Muted)";
        }

        chatMicButton.addEventListener('click', () => {
            if (isMicMuted) {
                setupMicrophone();
            } else {
                stopMicrophone();
            }
        });

        stopMicrophone();

        async function sendChatMessage({text, audioBlob}) {
            let payload = {};
            let hasContent = false;

            if (text) {
                payload.text = text;
                hasContent = true;
            }

            if (audioBlob) {
                try {
                    const base64Data = await blobToBase64(audioBlob);
                    payload.inlineData = {
                        mimeType: audioBlob.type || 'audio/webm',
                        data: base64Data
                    };
                    hasContent = true;
                } catch (error) {
                    console.error('Error converting blob to base64:', error);
                    addMessageToChat("Error processing audio for sending.", 'system-error');
                    return;
                }
            }

            if (!hasContent) {
                console.log("No content to send in chat message.");
                return;
            }

            try {
                const response = await fetch(coachAgentURL + '/api/v1/chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server error: ${response.status} ${errorText}`);
                }

                const data = await response.json();

                if (data.status === 'success' && data.part) {
                    if (data.part.text) {
                        addMessageToChat(data.part.text, 'received');
                    }
                    if (data.part.inlineData && data.part.inlineData.data) {
                        const audioUrl = `data:${data.part.inlineData.mimeType};base64,${data.part.inlineData.data}`;
                        addMessageToChat(null, 'received', true, audioUrl);
                    }
                    if (data.action === "REFRESH_DAILY_DATA") {
                        addMessageToChat("Agent updated daily values. Refreshing...", "system-info");
                        await loadDailyPlanData(formatDate(currentDate));
                        displayPlan(currentPlanTemplate, currentDailyPlanData);
                    }

                } else if (data.error) {
                    addMessageToChat(`Agent error: ${data.error}`, 'system-error');
                } else {
                    addMessageToChat("Received an unexpected response from the agent.", 'system-error');
                }
            } catch (error) {
                console.error('Error sending/receiving chat message:', error);
                addMessageToChat(`Network or server error: ${error.message}`, 'system-error');
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }


        chatDeleteSessionButton.addEventListener('click', () => {
            if (!confirm("Are you sure you want to delete the session and clear chat history?")) {
                return;
            }

            fetch(coachAgentURL + '/api/v1/chat', {
                method: 'DELETE',
            })
                .then(response => {
                    if (response.ok) {
                        chatHistory.innerHTML = '';
                        addMessageToChat("Session and history cleared.", 'system-info');
                        console.log("Chat session deleted successfully.");
                    } else {
                        response.text().then(text => {
                            addMessageToChat(`Error deleting session: ${response.status} ${text || ''}`, 'system-error');
                            console.error('Error deleting session:', response.status, text);
                        });
                    }
                })
                .catch(error => {
                    addMessageToChat("Network error while deleting session.", 'system-error');
                    console.error('Network error deleting session:', error);
                });
        });

        const userEmail = "guillaume.blaquiere@gmail.com"
        let ws;

        function connectWebSocket() {
            // Construire l'URL du WebSocket
            const wsURL = `${coachBackendURL.replace('http', 'ws')}/api/v1/ws?email=${encodeURIComponent(userEmail)}`;
            console.log("Connecting to WebSocket:", wsURL);

            ws = new WebSocket(wsURL);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                addMessageToChat("Real-time connection active.", "system-success");
            };

            ws.onmessage = (event) => {
                console.log("WebSocket message received:", event.data);
                try {
                    const message = JSON.parse(event.data);

                    if (message.action === 'PLAN_UPDATED') {
                        addMessageToChat("Your plan has been updated in real-time!", "system-info");

                        currentDailyPlanData = message.data;

                        if (currentPlanTemplate) {
                            displayPlan(currentPlanTemplate, currentDailyPlanData);
                        }
                    }
                } catch (error) {
                    console.error("Error parsing WebSocket message:", error);
                }
            };

            ws.onclose = (event) => {
                console.log("WebSocket connection closed.", event);
                addMessageToChat("Real-time connection lost. Attempting to reconnect...", "system-error");
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                addMessageToChat("A real-time connection error occurred.", "system-error");
            };
        }
        connectWebSocket()
    })
        // End of DOMContentLoaded
</script>
</body>
</html>