<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Plan</title>
    <style>
        body {
            font-family: sans-serif;
            margin-right: 350px; /* Space for the chat pane */
            position: relative; /* For chat pane positioning context if needed */
        }

        .date-controls {
            text-align: center;
            margin: 20px 0;
        }

        .date-controls button {
            padding: 5px 10px;
            margin: 0 10px;
        }

        #date-display {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
        }

        .accordion {
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #f0f0f0;
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .accordion-header h3 {
            margin: 0;
        }

        .accordion-content {
            padding: 10px;
            display: none; /* Hidden by default */
        }

        .accordion-content.show {
            display: block;
        }

        .drill {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .drill-name {
            font-weight: bold;
        }

        .drill-controls {
            margin-top: 5px;
            display: flex;
            align-items: center;
        }

        .drill-controls button {
            padding: 3px 8px;
            margin: 0 5px;
        }

        .drill-repetition {
            width: 50px;
            padding: 3px;
            margin: 0 5px;
            text-align: center;
        }

        .accordion-header .category-reps {
            font-size: 0.9em;
            color: #555;
        }

        .read-only {
            pointer-events: none;
            opacity: 0.7;
        }

        /* Chat Pane Styles */
        #chat-pane {
            position: fixed;
            right: 0;
            top: 0;
            width: 350px;
            height: 100%;
            border-left: 1px solid #ccc;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            z-index: 1000; /* Ensure it's on top */
        }

        #chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .chat-message {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 18px;
            max-width: 90%; /* Adjusted for better fit */
            word-wrap: break-word;
        }

        .chat-message.user {
            background-color: #dcf8c6;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .chat-message.audio {
            background-color: #e0e0e0; /* Different background for audio */
            align-self: flex-end; /* Assuming user recorded audio */
        }

        .chat-message.audio audio {
            display: block;
            margin-top: 5px;
            max-width: 100%;
            height: 40px; /* Consistent height for audio player */
        }


        #chat-input-area {
            display: flex;
            padding: 10px;
            border-top: 1px solid #ccc;
            background-color: #fff;
            align-items: center;
        }

        #chat-input-area {
            display: flex;
            flex-direction: column; /* Chang√© pour empiler les √©l√©ments verticalement */
            padding: 10px;
            border-top: 1px solid #ccc;
            background-color: #fff;
            /* align-items: center; */ /* Peut √™tre ajust√© ou supprim√© selon le besoin */
        }

        .message-controls-row {
            display: flex;
            width: 100%;
            align-items: center;
            margin-top: 5px; /* Ajoute un petit espace si vad-controls a une marge en bas */
        }

        #chat-send-button, #chat-mic-button {
            padding: 0; /* Remove padding to rely on width/height */
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            margin-left: 5px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* Adjust icon size */
        }

        #chat-mic-button.muted {
            background-color: #6c757d; /* Grey when muted */
        }

        #chat-mic-button.recording {
            background-color: #dc3545; /* Red when recording */
        }

        #chat-send-button, #chat-mic-button, #chat-delete-session-button { /* Ajout de #chat-delete-session-button */
            padding: 0;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            margin-left: 5px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        #chat-delete-session-button { /* Style sp√©cifique si besoin, par ex. couleur diff√©rente */
            background-color: #dc3545; /* Rouge pour une action de suppression */
        }
    </style>
</head>
<body>
<div class="date-controls">
    <button id="prev-day">&lt;</button>
    <span id="date-display"></span>
    <button id="next-day">&gt;</button>
    <input type="date" id="date-picker" style="display: none;">
</div>

<div id="plan-container">
    <!-- Training plan content will be loaded here -->
</div>

<!-- Chat Pane -->
<div id="chat-pane">
    <div id="chat-history">
        <!-- Messages will be appended here -->
    </div>
    <div id="chat-input-area">
        <div id="vad-controls" style="display: flex; flex-direction: column; margin-bottom: 5px; width: 100%;">
            <label for="vad-threshold-slider" style="font-size: 0.8em; margin-bottom: 2px;">Seuil VAD:</label> <!-- Label simplifi√© -->
            <div style="display: flex; align-items: center;">
                <input type="range" id="vad-threshold-slider" min="1" max="80" step="1" value="15"
                       style="flex-grow: 1; margin-right: 5px;">
                <span id="vad-threshold-value" style="font-size: 0.8em; min-width: 25px; text-align: right;">15</span>
            </div>
            <progress id="mic-gain-meter" value="0" max="255"
                      style="width: 100%; height: 5px; margin-top: 2px;"></progress>
        </div>
        <div class="message-controls-row">
            <input type="text" id="chat-message-input" placeholder="Type a message...">
            <button id="chat-send-button" title="Send">‚ûî</button>
            <button id="chat-mic-button" title="Toggle Microphone">üé§</button>
            <button id="chat-delete-session-button" title="Delete Session">üóëÔ∏è</button> <!-- NOUVEAU BOUTON -->
        </div>
    </div>
</div>

<script>
    // Existing Training Plan JavaScript
    const dateDisplay = document.getElementById('date-display');
    const datePicker = document.getElementById('date-picker');
    const prevDayButton = document.getElementById('prev-day');
    const nextDayButton = document.getElementById('next-day');
    const planContainer = document.getElementById('plan-container');
    // For local testing. Removed for the deployment (see dockerfile)
    const coachBackendURL = "http://localhost:8080"
    const coachAgentURL = "http://localhost:8081"

    let currentDate = new Date();
    let isToday = true;

    function formatDate(date) {
        return date.toISOString().slice(0, 10);
    }

    function updateDateDisplay() {
        dateDisplay.textContent = formatDate(currentDate);
        isToday = formatDate(currentDate) === formatDate(new Date());
        planContainer.classList.toggle('read-only', !isToday);
    }

    function loadPlan() {
        const dateStr = formatDate(currentDate);
        fetch(coachBackendURL + `/api/v1/daily-plans/${dateStr === formatDate(new Date()) ? 'today' : dateStr}`)
            .then(response => {
                if (response.status === 404 && dateStr === formatDate(new Date())) {
                    return fetch(coachBackendURL + '/api/v1/daily-plans/initiate', {method: 'POST'})
                        .then(initResponse => initResponse.json());
                }
                return response.json();
            })
            .then(plan => {
                if (plan && plan.categories) {
                    displayPlan(plan);
                } else {
                    planContainer.innerHTML = '<p>No plan found for this date.</p>';
                }
            })
            .catch(error => {
                console.error('Error loading plan:', error);
                planContainer.innerHTML = `<p>Error loading plan: ${error.message}</p>`;
            });
    }

    function displayPlan(plan) {
        planContainer.innerHTML = '';
        for (const categoryId in plan.categories) {
            const category = plan.categories[categoryId];
            const categoryElement = document.createElement('div');
            categoryElement.classList.add('accordion');
            categoryElement.dataset.categoryId = categoryId;

            const header = document.createElement('div');
            header.classList.add('accordion-header');
            header.innerHTML = `<h3>${category.name}</h3>`;

            const categoryReps = document.createElement('span');
            categoryReps.classList.add('category-reps');
            header.appendChild(categoryReps);

            const catButtons = document.createElement('div');
            const catIncButton = document.createElement('button');
            catIncButton.textContent = '+';
            catIncButton.onclick = () => adjustCategoryReps(categoryId, 1);
            const catDecButton = document.createElement('button');
            catDecButton.textContent = '-';
            catDecButton.onclick = () => adjustCategoryReps(categoryId, -1);
            catButtons.append(catIncButton, catDecButton);
            header.appendChild(catButtons)

            categoryElement.appendChild(header);

            const content = document.createElement('div');
            content.classList.add('accordion-content', 'show');

            let minReps = Infinity;

            for (const drillId in category.drills) {
                const drill = category.drills[drillId];
                const drillElement = document.createElement('div');
                drillElement.classList.add('drill');
                drillElement.dataset.drillId = drillId;
                drillElement.dataset.categoryId = categoryId;

                const drillName = document.createElement('div');
                drillName.classList.add('drill-name');
                drillName.textContent = drill.name;
                drillElement.appendChild(drillName);

                const drillDesc = document.createElement('div');
                drillDesc.classList.add('drill-desc');
                drillDesc.textContent = drill.description;
                drillElement.appendChild(drillDesc);

                const drillControls = document.createElement('div');
                drillControls.classList.add('drill-controls');
                const decButton = document.createElement('button');
                decButton.textContent = '-';
                decButton.onclick = () => adjustDrillReps(categoryId, drillId, -1);

                const incButton = document.createElement('button');
                incButton.textContent = '+';
                incButton.onclick = () => adjustDrillReps(categoryId, drillId, 1);

                const repsDisplay = document.createElement('span');
                repsDisplay.classList.add('drill-repetition');
                repsDisplay.textContent = drill.repetition || 0;

                drillControls.append(decButton, repsDisplay, incButton);
                drillElement.appendChild(drillControls);
                content.appendChild(drillElement);
                minReps = Math.min(minReps, drill.repetition || 0);
            }
            categoryReps.textContent = `(Min Reps: ${minReps === Infinity ? 0 : minReps})`;
            categoryElement.appendChild(content);
            planContainer.appendChild(categoryElement);

            header.addEventListener('click', () => {
                content.classList.toggle('show');
            });
        }
        updateDateDisplay(); // Ensure read-only state is applied after display
    }

    function adjustCategoryReps(categoryId, adjustment) {
        const plan = getCurrentPlan();
        if (!plan || !plan.categories[categoryId]) return;
        const drillsToUpdate = [];
        for (const drillId in plan.categories[categoryId].drills) {
            const drill = plan.categories[categoryId].drills[drillId];
            let newReps = (drill.repetition || 0) + adjustment;
            if (newReps < 0) newReps = 0;
            drillsToUpdate.push({categoryId, drillId, repetition: newReps});
            drill.repetition = newReps;
        }
        saveMultipleDrillUpdates(drillsToUpdate);
    }

    function adjustDrillReps(categoryId, drillId, adjustment) {
        const plan = getCurrentPlan();
        if (!plan || !plan.categories[categoryId] || !plan.categories[categoryId].drills[drillId]) return;
        const drill = plan.categories[categoryId].drills[drillId];
        let newReps = (drill.repetition || 0) + adjustment;
        if (newReps < 0) newReps = 0;
        drill.repetition = newReps;
        saveDrillUpdate(categoryId, drillId, newReps);
    }

    function saveDrillUpdate(categoryId, drillId, newReps) {
        saveMultipleDrillUpdates([{categoryId, drillId, repetition: newReps}]);
    }

    function saveMultipleDrillUpdates(drillsToUpdate) {
        if (!isToday || drillsToUpdate.length === 0) return;
        const updates = {};
        drillsToUpdate.forEach(({categoryId, drillId, repetition}) => {
            if (!updates[categoryId]) updates[categoryId] = {drills: {}};
            if (!updates[categoryId].drills[drillId]) updates[categoryId].drills[drillId] = {};
            updates[categoryId].drills[drillId].repetition = repetition;
        });

        fetch(coachBackendURL + '/api/v1/daily-plans/today', {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({categories: updates})
        })
            .then(response => response.json())
            .then(updatedPlanFromServer => displayPlan(updatedPlanFromServer))
            .catch(error => console.error('Error updating plan:', error));
    }

    function getCurrentPlan() {
        const planElements = planContainer.querySelectorAll('.accordion');
        if (planElements.length === 0) return null;
        const plan = {categories: {}};
        planElements.forEach(categoryElement => {
            const categoryId = categoryElement.dataset.categoryId;
            plan.categories[categoryId] = {drills: {}};
            categoryElement.querySelectorAll('.drill').forEach(drillElement => {
                const drillId = drillElement.dataset.drillId;
                const repetition = parseInt(drillElement.querySelector('.drill-repetition').textContent);
                plan.categories[categoryId].drills[drillId] = {repetition: repetition};
            });
        });
        return plan;
    }

    dateDisplay.addEventListener('click', () => {
        datePicker.style.display = 'block';
        datePicker.value = formatDate(currentDate);
        datePicker.focus();
    });
    datePicker.addEventListener('change', () => {
        currentDate = new Date(datePicker.value);
        datePicker.style.display = 'none';
        updateDateDisplay();
        loadPlan();
    });
    prevDayButton.addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() - 1);
        updateDateDisplay();
        loadPlan();
    });
    nextDayButton.addEventListener('click', () => {
        currentDate.setDate(currentDate.getDate() + 1);
        updateDateDisplay();
        loadPlan();
    });

    // Initial load for training plan
    updateDateDisplay();
    loadPlan();

    // --- Chat Pane JavaScript ---
    const chatHistory = document.getElementById('chat-history');
    const chatMessageInput = document.getElementById('chat-message-input');
    const chatSendButton = document.getElementById('chat-send-button');
    const chatMicButton = document.getElementById('chat-mic-button');
    const chatDeleteSessionButton = document.getElementById('chat-delete-session-button');
    const vadThresholdSlider = document.getElementById('vad-threshold-slider');
    const vadThresholdValueDisplay = document.getElementById('vad-threshold-value');
    const micGainMeter = document.getElementById('mic-gain-meter');

    let mediaRecorder;
    let audioChunks = [];
    let isMicMuted = true; // Start muted
    let audioContext;
    let analyser;
    let microphoneStream;
    let vadInterval;
    const MIN_RECORDING_DURATION_MS = 300;
    const VAD_CHECK_INTERVAL = 10;
    let VAD_THRESHOLD = parseFloat(vadThresholdSlider.value); // Initialisez avec la valeur du slider
    const SILENCE_DURATION_THRESHOLD = 500;
    let silenceStartTime = 0;
    let hasDetectedSpeechInSegment = false; // More specific name

    vadThresholdSlider.addEventListener('input', () => {
        VAD_THRESHOLD = parseFloat(vadThresholdSlider.value);
        vadThresholdValueDisplay.textContent = VAD_THRESHOLD.toFixed(0);
    });

    function addMessageToChat(text, type = 'user', isAudio = false, audioBlobUrl = null) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('chat-message', type);

        if (isAudio && audioBlobUrl) {
            messageElement.classList.add('audio');
            const audioElement = document.createElement('audio');
            audioElement.controls = true;
            audioElement.src = audioBlobUrl;
            messageElement.appendChild(audioElement);
        } else {
            messageElement.textContent = text;
        }

        chatHistory.appendChild(messageElement);
        chatHistory.scrollTop = chatHistory.scrollHeight;
        //Play audio automatically if type is not user
        if (type !== 'user') {
            const audioElement = messageElement.querySelector('audio');
            if (audioElement) {
                audioElement.play().catch(e => console.warn("Audio playback failed:", e));
            }
        }
    }

    chatSendButton.addEventListener('click', () => {
        const messageText = chatMessageInput.value.trim();
        if (messageText) {
            addMessageToChat(messageText, 'user');
            chatMessageInput.value = '';
            sendChatMessage(messageText, null); // Send text message
        }
    });

    chatMessageInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            chatSendButton.click();
        }
    });

    async function setupMicrophone() {
        try {
            microphoneStream = await navigator.mediaDevices.getUserMedia({audio: true});
            chatMicButton.classList.remove('muted');
            chatMicButton.title = "Mute Microphone";
            isMicMuted = false;
            hasDetectedSpeechInSegment = false;
            audioChunks = [];

            mediaRecorder = new MediaRecorder(microphoneStream);
            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            // Dans la fonction setupMicrophone
            mediaRecorder.onstop = async () => { // Rendre la fonction async
                if (hasDetectedSpeechInSegment && audioChunks.length > 0) {
                    const audioBlob = new Blob(audioChunks, {type: 'audio/webm'}); // ou 'audio/wav' selon ce que vous utilisez

                    // D√©terminer la dur√©e de l'audioBlob
                    try {
                        const tempAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const audioBuffer = await tempAudioContext.decodeAudioData(arrayBuffer);
                        await tempAudioContext.close(); // Important de fermer le contexte temporaire

                        const durationMs = audioBuffer.duration * 1000;

                        if (durationMs >= MIN_RECORDING_DURATION_MS) {
                            const audioUrl = URL.createObjectURL(audioBlob);
                            addMessageToChat(null, 'user', true, audioUrl);
                            sendChatMessage(null, audioBlob);
                            console.log(`Audio sent, duration: ${durationMs.toFixed(0)}ms`);
                        } else {
                            console.log(`Audio discarded, duration too short: ${durationMs.toFixed(0)}ms`);
                            // Optionnel: informer l'utilisateur que l'audio √©tait trop court
                            // addMessageToChat("Audio too short, discarded.", "system-info");
                        }
                    } catch (e) {
                        console.error("Error decoding audio or getting duration:", e);
                        // En cas d'erreur de d√©codage, on pourrait choisir d'envoyer quand m√™me
                        // ou de le consid√©rer comme invalide. Pour l'instant, on ne fait rien.
                        const audioUrl = URL.createObjectURL(audioBlob); // Fallback: send it anyway or handle error
                        addMessageToChat(null, 'user', true, audioUrl);
                        sendChatMessage(null, audioBlob);
                        addMessageToChat("Could not determine audio duration, sent anyway.", "system-warning");
                    }
                }

                audioChunks = []; // Toujours vider les chunks
                hasDetectedSpeechInSegment = false; // Toujours r√©initialiser

                // Mettre √† jour l'UI si le micro n'est pas mut√© entre-temps
                if (!isMicMuted) {
                    chatMicButton.classList.remove('recording');
                    chatMicButton.title = "Mute Microphone";
                }
            };


            // Ne pas d√©marrer MediaRecorder ici, VAD s'en chargera.

            // AJOUT D'UNE TEMPORISATION AVANT DE D√âMARRER L'ANALYSE VAD
            setTimeout(() => {
                if (isMicMuted || !microphoneStream) {
                    // Si entre-temps l'utilisateur a remu√© ou si le stream n'est plus valide
                    return;
                }

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(microphoneStream);
                source.connect(analyser);
                analyser.fftSize = 512;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);

                if (vadInterval) clearInterval(vadInterval); // S'assurer qu'il n'y a pas d'intervalle pr√©c√©dent actif

                vadInterval = setInterval(() => {
                    if (isMicMuted) {
                        if (mediaRecorder && mediaRecorder.state === "recording") {
                            mediaRecorder.stop();
                        }
                        micGainMeter.value = 0;
                        return;
                    }
                    if (!mediaRecorder || !analyser) {
                        micGainMeter.value = 0;
                        return;
                    }

                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const averageVolume = sum / dataArray.length;
                    micGainMeter.value = averageVolume;

                    if (averageVolume > VAD_THRESHOLD) {
                        if (mediaRecorder.state === "inactive") {
                            audioChunks = [];
                            mediaRecorder.start(VAD_CHECK_INTERVAL);
                            hasDetectedSpeechInSegment = true;
                            chatMicButton.classList.add('recording');
                            chatMicButton.title = "Recording...";
                        }
                        silenceStartTime = 0;
                    } else {
                        if (mediaRecorder.state === "recording") {
                            if (silenceStartTime === 0) {
                                silenceStartTime = Date.now();
                            } else if (Date.now() - silenceStartTime > SILENCE_DURATION_THRESHOLD) {
                                mediaRecorder.stop();
                                silenceStartTime = 0;
                            }
                        }
                    }
                }, VAD_CHECK_INTERVAL);
            }, 2500); // Temporisation de 150ms (ajustez si besoin)

        } catch (err) {
            console.error("Error accessing microphone:", err);
            addMessageToChat("Microphone access denied or error.", "system-error");
            isMicMuted = true;
            chatMicButton.classList.add('muted');
            chatMicButton.textContent = 'üé§';
            chatMicButton.title = "Microphone Disabled";
            stopMicrophoneInternals(true);
        }
    }

    function stopMicrophoneInternals(isError = false) {
        if (microphoneStream) {
            microphoneStream.getTracks().forEach(track => track.stop());
            microphoneStream = null;
        }

        if (mediaRecorder) {
            // If it's not an error and recorder is active, let onstop handle the final chunks.
            // Otherwise, if it's an error, we just want to stop it without processing.
            if (!isError && mediaRecorder.state === "recording") {
                // The onstop handler should take care of processing the last segment
                mediaRecorder.stop();
            } else if (mediaRecorder.state !== "inactive") {
                mediaRecorder.onstop = null; // Prevent onstop if we are force stopping due to error
                mediaRecorder.stop();
            }
        }
        mediaRecorder = null;

        if (audioContext) {
            audioContext.close().catch(e => console.warn("Error closing audio context:", e));
            audioContext = null;
        }
        if (vadInterval) {
            clearInterval(vadInterval);
            vadInterval = null;
        }

        hasDetectedSpeechInSegment = false;
        audioChunks = [];
        silenceStartTime = 0;
    }


    function stopMicrophone() {
        // This function is called when the user clicks the mute button
        isMicMuted = true; // Set muted state first
        stopMicrophoneInternals(false); // Not an error state, allow onstop to process final segment if recording

        // Update UI
        chatMicButton.classList.add('muted');
        chatMicButton.classList.remove('recording');
        chatMicButton.textContent = 'üé§';
        chatMicButton.title = "Toggle Microphone";
    }

    chatMicButton.addEventListener('click', () => {
        if (isMicMuted) {
            setupMicrophone();
        } else {
            stopMicrophone(); // This will set isMicMuted = true and call stopMicrophoneInternals
        }
    });

    // Initial state for mic button
    chatMicButton.classList.add('muted');
    chatMicButton.textContent = 'üé§';
    vadThresholdValueDisplay.textContent = VAD_THRESHOLD.toFixed(0);


    function sendChatMessage(messageText, audioBlob) {
        let payload = {};
        if (messageText) {
            payload.text = messageText;
        }
        if (audioBlob) {
            const reader = new FileReader();
            reader.onloadend = function () {
                const base64Data = reader.result.split(',')[1];
                payload.inlineData = {
                    mimeType: audioBlob.type,
                    data: base64Data
                };
                fetch(coachAgentURL + '/api/v1/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            if (data.part.text) {
                                addMessageToChat(data.part.text, 'received');
                            }
                            if (data.part.inlineData) {
                                const audioUrl = "data:" + data.part.inlineData.mimeType + ";base64," + data.part.inlineData.data;
                                addMessageToChat(null, 'received', true, audioUrl);
                            }
                            // V√©rifier l'action et rafra√Æchir le plan si n√©cessaire
                            if (data.action === "PUT") {
                                loadPlan(); // Appelle la fonction pour recharger le plan
                            }
                        } else if (data.error) {
                            addMessageToChat("Error: " + data.error, 'system-error');
                        } else {
                            addMessageToChat("Unknown error communicating with the server.", 'system-error');
                        }
                    })
                    .catch(error => {
                        console.error('Error sending chat message:', error);
                        addMessageToChat("Error sending message to the server.", 'system-error');
                    });
            };
            reader.readAsDataURL(audioBlob);
        } else {
            fetch(coachAgentURL + '/api/v1/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        if (data.part.text) {
                            addMessageToChat(data.part.text, 'received');
                        }
                        if (data.part.inlineData) {
                            const audioUrl = "data:" + data.part.inlineData.mimeType + ";base64," + data.part.inlineData.data;
                            addMessageToChat(null, 'received', true, audioUrl);
                        }
                        // V√©rifier l'action et rafra√Æchir le plan si n√©cessaire
                        if (data.action === "PUT") {
                            loadPlan(); // Appelle la fonction pour recharger le plan
                        }
                    } else if (data.error) {
                        addMessageToChat("Error: " + data.error, 'system-error');
                    } else {
                        addMessageToChat("Unknown error communicating with the server.", 'system-error');
                    }
                })
                .catch(error => {
                    console.error('Error sending chat message:', error);
                    addMessageToChat("Error sending message to the server.", 'system-error');
                });
        }
    }

    chatDeleteSessionButton.addEventListener('click', () => {
        // Optionnel : Demander une confirmation √† l'utilisateur
        if (!confirm("√ätes-vous s√ªr de vouloir supprimer la session et effacer l'historique du chat ?")) {
            return;
        }

        fetch(coachAgentURL + '/api/v1/chat', {
            method: 'DELETE',
            headers: {
                // Ajoutez des headers si votre backend en a besoin pour l'authentification,
                // par exemple 'X-User-Email' si vous l'utilisez comme dans votre backend Go.
                // 'Content-Type': 'application/json' // Pas typiquement n√©cessaire pour un DELETE sans corps
            }
        })
            .then(response => {
                if (response.ok) { // V√©rifie si le statut est 2xx (par exemple 200 OK ou 204 No Content)
                    chatHistory.innerHTML = ''; // Efface tous les messages du chat
                    addMessageToChat("Session et historique effac√©s.", 'system-info'); // Message de confirmation
                    console.log("Session deleted successfully.");
                } else {
                    // G√©rer les erreurs si la suppression √©choue
                    response.text().then(text => { // Essayer de lire le corps de la r√©ponse en cas d'erreur
                        addMessageToChat(`Erreur lors de la suppression de la session: ${response.status} ${text}`, 'system-error');
                        console.error('Error deleting session:', response.status, text);
                    });
                }
            })
            .catch(error => {
                addMessageToChat("Erreur r√©seau lors de la suppression de la session.", 'system-error');
                console.error('Network error deleting session:', error);
            });
    });

</script>
</body>
</html>