<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Training Plan</title>
    <style>
        body {
            font-family: sans-serif;
            margin-right: 350px; /* Space for the chat pane */
            position: relative; /* For chat pane positioning context if needed */
        }

        .date-controls {
            text-align: center;
            margin: 20px 0;
        }

        .date-controls button {
            padding: 5px 10px;
            margin: 0 10px;
        }

        #date-display {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
        }

        .accordion {
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        .accordion-header {
            background-color: #f0f0f0;
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .accordion-header h3 {
            margin: 0;
        }

        .accordion-content {
            padding: 10px;
            display: none; /* Hidden by default */
        }

        .accordion-content.show {
            display: block;
        }

        .drill {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .drill-name {
            font-weight: bold;
        }

        .drill-desc {
            font-size: 0.9em;
            color: #333;
            margin-top: 3px;
        }

        .drill-controls {
            margin-top: 5px;
            display: flex;
            align-items: center;
        }

        .drill-controls button {
            padding: 3px 8px;
            margin: 0 5px;
        }

        .drill-repetition {
            width: 50px;
            padding: 3px;
            margin: 0 5px;
            text-align: center;
        }

        /* NEW STYLE FOR NOTE INPUT */
        .drill-note-input {
            flex-grow: 1;
            padding: 3px;
            margin-left: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .accordion-header .category-reps {
            font-size: 0.9em;
            color: #555;
        }

        .read-only {
            pointer-events: none;
            opacity: 0.7;
        }

        /* Chat Pane Styles */
        #chat-pane {
            position: fixed;
            right: 0;
            top: 0;
            width: 350px;
            height: 100%;
            border-left: 1px solid #ccc;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            z-index: 1000; /* Ensure it's on top */
        }

        #chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .chat-message {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 18px;
            max-width: 90%; /* Adjusted for better fit */
            word-wrap: break-word;
        }

        .chat-message.user {
            background-color: #dcf8c6;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        /* NEW: Style for agent messages */
        .chat-message.agent {
            background-color: #e6e6e6; /* Light grey for agent messages */
            align-self: flex-start; /* Align to the left */
            border-bottom-left-radius: 4px;
        }

        .chat-message.audio {
            background-color: #e0e0e0; /* Different background for audio */
            align-self: flex-end; /* Assuming user recorded audio */
        }

        .chat-message.audio audio {
            display: block;
            margin-top: 5px;
            max-width: 100%;
            height: 40px; /* Consistent height for audio player */
        }


        #chat-input-area {
            display: flex;
            flex-direction: column; /* Changed to stack elements vertically */
            padding: 10px;
            border-top: 1px solid #ccc;
            background-color: #fff;
        }

        .message-controls-row {
            display: flex;
            width: 100%;
            align-items: center;
            margin-top: 5px; /* Adds a small space if vad-controls has a bottom margin */
        }

        #chat-message-input {
            flex-grow: 1; /* Allow input to take available space */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 18px;
            margin-right: 5px;
        }

        #chat-send-button, #chat-mic-button, #chat-delete-session-button { /* Added #chat-delete-session-button */
            padding: 0;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            margin-left: 5px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }

        #chat-mic-button.muted {
            background-color: #6c757d; /* Grey when muted */
        }

        #chat-mic-button.recording {
            background-color: #dc3545; /* Red when streaming is active */
        }

        #chat-delete-session-button { /* Specific style if needed, e.g., different color */
            background-color: #dc3545; /* Red for a delete action */
        }

        /* NEW: Style for mic gain slider */
        .mic-gain-control {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            font-size: 0.8em;
        }

        .mic-gain-control input[type="range"] {
            flex-grow: 1;
            margin-left: 10px;
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            height: 4px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 2px;
        }

        .mic-gain-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .mic-gain-control input[type="range"]::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="date-controls">
    <button id="prev-day">&lt;</button>
    <span id="date-display"></span>
    <button id="next-day">&gt;</button>
    <input type="date" id="date-picker" style="display: none;">
</div>

<div id="plan-container">
    <!-- Training plan content will be loaded here -->
</div>

<!-- Chat Pane -->
<div id="chat-pane">
    <div id="chat-history">
        <!-- Messages will be appended here -->
    </div>
    <div id="chat-input-area">
        <!-- NEW: VU Meter for mic activity -->
        <div id="vad-controls" style="display: flex; align-items: center; width: 100%; margin-bottom: 5px;">
            <span style="margin-right: 10px; font-size: 0.8em;">Mic Activity:</span>
            <div id="vu-meter" style="flex-grow: 1; height: 10px; background-color: #e0e0e0; border: 1px solid #ccc; border-radius: 5px; overflow: hidden;">
                <div id="vu-meter-level" style="width: 0%; height: 100%; background-color: #4caf50; transition: width 0.05s ease-out;"></div>
            </div>
        </div>
        <!-- NEW: Mic Gain Control -->
        <div class="mic-gain-control">
            <span>Mic Gain:</span>
            <input type="range" id="mic-gain-slider" min="0.5" max="3.0" value="1.0" step="0.1">
        </div>
        <div class="message-controls-row">
            <input type="text" id="chat-message-input" placeholder="Type a message...">
            <button id="chat-send-button" title="Send">‚ûî</button>
            <button id="chat-mic-button" title="Toggle Microphone">üé§</button>
            <button id="chat-delete-session-button" title="Delete Session">üóëÔ∏è</button> <!-- NEW BUTTON -->
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Existing Training Plan JavaScript
        const dateDisplay = document.getElementById('date-display');
        const datePicker = document.getElementById('date-picker');
        const prevDayButton = document.getElementById('prev-day');
        const nextDayButton = document.getElementById('next-day');
        const planContainer = document.getElementById('plan-container');
        // For local testing. Removed for the deployment (see dockerfile)
        const coachBackendURL = "http://localhost:8080"
        const coachAgentURL = "http://localhost:8081"

        let currentDate = new Date();
        let isToday = true;
        let currentPlanTemplate = null; // To store the plan structure (categories, drills)
        let currentDailyPlanData = null; // To store daily achievements (repetitions, notes)

        function formatDate(date) {
            return date.toISOString().slice(0, 10);
        }

        function updateDateDisplay() {
            dateDisplay.textContent = formatDate(currentDate);
            isToday = formatDate(currentDate) === formatDate(new Date());
            planContainer.classList.toggle('read-only', !isToday);
        }

        async function loadPlanTemplate() {
            if (currentPlanTemplate) {
                return Promise.resolve(currentPlanTemplate);
            }
            try {
                const response = await fetch(coachBackendURL + '/api/v1/plan-templates/default');
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Template fetch failed: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                currentPlanTemplate = await response.json();
                return currentPlanTemplate;
            } catch (error) {
                console.error('Error loading plan template:', error);
                planContainer.innerHTML = `<p>Error loading plan structure: ${error.message}</p>`;
                throw error;
            }
        }

        async function loadDailyPlanData(dateStr) {
            const endpoint = `/api/v1/daily-plans/${dateStr === formatDate(new Date()) ? 'today' : dateStr}`;
            try {
                let response = await fetch(coachBackendURL + endpoint);
                if (response.status === 404 && dateStr === formatDate(new Date())) {
                    const initResponse = await fetch(coachBackendURL + '/api/v1/daily-plans/initiate', {method: 'POST'});
                    if (!initResponse.ok) {
                        const errorData = await initResponse.json().catch(() => ({}));
                        throw new Error(`Failed to initiate plan: ${initResponse.statusText} (${errorData.error || 'Unknown error'})`);
                    }
                    currentDailyPlanData = await initResponse.json();
                } else if (response.status === 404) { // Not found for a past date
                    currentDailyPlanData = null; // No data exists, will display template with 0 reps
                } else if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to load daily plan: ${response.statusText} (${errorData.error || 'Plan not found'})`);
                } else {
                    currentDailyPlanData = await response.json();
                }
                return currentDailyPlanData;
            } catch (error) {
                console.error('Error loading daily plan data:', error);
                planContainer.innerHTML = `<p>Error loading plan data: ${error.message}</p>`;
                currentDailyPlanData = null;
                throw error;
            }
        }

        async function loadPlan() {
            const dateStr = formatDate(currentDate);
            planContainer.innerHTML = '<p>Loading plan...</p>';
            updateDateDisplay(); // Update read-only status and date display early

            try {
                await loadPlanTemplate();
                await loadDailyPlanData(dateStr);

                if (currentPlanTemplate) { // Always try to display template structure
                    displayPlan(currentPlanTemplate, currentDailyPlanData);
                } else {
                    // Error message for template loading failure is already set by loadPlanTemplate
                }
            } catch (error) {
                // Errors are logged by sub-functions, planContainer might have specific error messages.
                console.error('Error in loadPlan orchestration:', error);
                if (!planContainer.innerHTML.includes("Error") && !planContainer.innerHTML.includes("Loading")) {
                    planContainer.innerHTML = `<p>An unexpected error occurred.</p>`;
                }
            }
        }

        function displayPlan(planTemplate, dailyPlanData) {
            planContainer.innerHTML = '';
            if (!planTemplate || !planTemplate.categories) {
                planContainer.innerHTML = '<p>No plan structure (template) available to display.</p>';
                return;
            }

            for (const categoryId in planTemplate.categories) {
                const category = planTemplate.categories[categoryId];
                const categoryElement = document.createElement('div');
                categoryElement.classList.add('accordion');
                categoryElement.dataset.categoryId = categoryId;

                const header = document.createElement('div');
                header.classList.add('accordion-header');
                header.innerHTML = `<h3>${category.name}</h3>`;

                const categoryRepsDisplay = document.createElement('span');
                categoryRepsDisplay.classList.add('category-reps');
                header.appendChild(categoryRepsDisplay);

                const catButtons = document.createElement('div');
                const catIncButton = document.createElement('button');
                catIncButton.textContent = '+';
                catIncButton.onclick = (e) => {
                    e.stopPropagation();
                    adjustCategoryReps(categoryId, 1);
                };
                const catDecButton = document.createElement('button');
                catDecButton.textContent = '-';
                catDecButton.onclick = (e) => {
                    e.stopPropagation();
                    adjustCategoryReps(categoryId, -1);
                };
                catButtons.append(catIncButton, catDecButton);
                header.appendChild(catButtons);

                categoryElement.appendChild(header);

                const content = document.createElement('div');
                content.classList.add('accordion-content', 'show'); // Default to show

                let minRepsInCategory = Infinity;
                let hasDrillsInCat = false;

                if (category.drills) {
                    for (const drillId in category.drills) {
                        hasDrillsInCat = true;
                        const drill = category.drills[drillId];
                        const drillElement = document.createElement('div');
                        drillElement.classList.add('drill');
                        drillElement.dataset.drillId = drillId;
                        drillElement.dataset.categoryId = categoryId;

                        const drillName = document.createElement('div');
                        drillName.classList.add('drill-name');
                        drillName.textContent = drill.name;
                        drillElement.appendChild(drillName);

                        if (drill.description) {
                            const drillDesc = document.createElement('div');
                            drillDesc.classList.add('drill-desc');
                            drillDesc.textContent = drill.description;
                            drillElement.appendChild(drillDesc);
                        }

                        const drillControls = document.createElement('div');
                        drillControls.classList.add('drill-controls');
                        const decButton = document.createElement('button');
                        decButton.textContent = '-';
                        decButton.onclick = () => adjustDrillReps(categoryId, drillId, -1);

                        const incButton = document.createElement('button');
                        incButton.textContent = '+';
                        incButton.onclick = () => adjustDrillReps(categoryId, drillId, 1);

                        const repsDisplay = document.createElement('span');
                        repsDisplay.classList.add('drill-repetition');

                        let currentRepetition = 0;
                        let currentNote = "";
                        // dailyPlanData might be null if no plan exists for a past date
                        if (dailyPlanData && dailyPlanData.repetitions &&
                            dailyPlanData.repetitions[categoryId] &&
                            dailyPlanData.repetitions[categoryId][drillId]) {
                            const achievement = dailyPlanData.repetitions[categoryId][drillId];
                            currentRepetition = achievement.repetition || 0;
                            currentNote = achievement.note || "";
                        }
                        repsDisplay.textContent = currentRepetition;
                        minRepsInCategory = Math.min(minRepsInCategory, currentRepetition);

                        // NOTE FIELD ADDED HERE
                        const noteInput = document.createElement('input');
                        noteInput.type = 'text';
                        noteInput.classList.add('drill-note-input');
                        noteInput.placeholder = 'Notes...';
                        noteInput.value = currentNote;
                        // End of note field addition

                        drillControls.append(decButton, repsDisplay, incButton, noteInput); // noteInput added here
                        drillElement.appendChild(drillControls);
                        content.appendChild(drillElement);
                    }
                }
                categoryRepsDisplay.textContent = `(Min Reps: ${hasDrillsInCat && minRepsInCategory !== Infinity ? minRepsInCategory : 0})`;
                categoryElement.appendChild(content);
                planContainer.appendChild(categoryElement);

                header.addEventListener('click', (e) => {
                    // Prevent accordion toggle if a button inside header was clicked
                    if (e.target.closest('button')) return;
                    content.classList.toggle('show');
                });
            }
            updateDateDisplay(); // Applies read-only if necessary
        }

        function ensureDailyPlanDataInitialized() {
            if (!currentDailyPlanData) {
                // Initialize a basic structure if today and no data (e.g., after initiation failed or for a new interaction)
                if (isToday) {
                    currentDailyPlanData = {
                        id: `${formatDate(currentDate)}-temp`, // Temporary ID
                        templateId: currentPlanTemplate?.id || "default",
                        date: formatDate(currentDate),
                        repetitions: {},
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    };
                } else {
                    console.warn("Cannot modify: No existing daily plan data for this past date.");
                    addMessageToChat("Cannot modify plan for a past date without existing data.", "system-warning");
                    return false;
                }
            }
            if (!currentDailyPlanData.repetitions) {
                currentDailyPlanData.repetitions = {};
            }
            return true;
        }


        function adjustDrillReps(categoryId, drillId, adjustment) {
            if (!currentPlanTemplate || !currentPlanTemplate.categories[categoryId]?.drills[drillId]) {
                console.warn("Drill definition not found in template.");
                return;
            }
            if (!isToday) { // Only allow edits for today
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }

            if (!ensureDailyPlanDataInitialized()) return;


            if (!currentDailyPlanData.repetitions[categoryId]) {
                currentDailyPlanData.repetitions[categoryId] = {};
            }
            if (!currentDailyPlanData.repetitions[categoryId][drillId]) {
                currentDailyPlanData.repetitions[categoryId][drillId] = {repetition: 0, note: ""};
            }

            let achievement = currentDailyPlanData.repetitions[categoryId][drillId];
            let newReps = (achievement.repetition || 0) + adjustment;
            if (newReps < 0) newReps = 0;

            // Get the current note from the input field in the DOM
            const drillElement = planContainer.querySelector(`.drill[data-category-id="${categoryId}"][data-drill-id="${drillId}"]`);
            let noteFromInput = achievement.note; // Default value
            if (drillElement) {
                const noteInputElement = drillElement.querySelector('.drill-note-input');
                if (noteInputElement) {
                    noteFromInput = noteInputElement.value;
                }
            }

            achievement.repetition = newReps;
            achievement.note = noteFromInput; // Update the note in local data

            displayPlan(currentPlanTemplate, currentDailyPlanData); // Optimistic UI update (re-renders with new note)

            saveDrillUpdate(categoryId, drillId, newReps, achievement.note); // Send the updated note
        }

        function adjustCategoryReps(categoryId, adjustment) {
            if (!currentPlanTemplate || !currentPlanTemplate.categories[categoryId]?.drills) {
                console.warn("Category or drills not found in template.");
                return;
            }
            if (!isToday) {
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }

            if (!ensureDailyPlanDataInitialized()) return;

            const categoryDrills = currentPlanTemplate.categories[categoryId].drills;
            const drillsToUpdate = {}; // Changed from [] to {} to match the expected payload

            if (!currentDailyPlanData.repetitions[categoryId]) {
                currentDailyPlanData.repetitions[categoryId] = {};
            }
            // Initialize drillsToUpdate[categoryId] if not already done
            if (!drillsToUpdate[categoryId]) {
                drillsToUpdate[categoryId] = {};
            }

            for (const drillId in categoryDrills) {
                if (!currentDailyPlanData.repetitions[categoryId][drillId]) {
                    currentDailyPlanData.repetitions[categoryId][drillId] = {repetition: 0, note: ""};
                }
                let achievement = currentDailyPlanData.repetitions[categoryId][drillId];
                let newReps = (achievement.repetition || 0) + adjustment;
                if (newReps < 0) newReps = 0;

                // Get the current note from the input field in the DOM for this drill
                const drillElement = planContainer.querySelector(`.drill[data-category-id="${categoryId}"][data-drill-id="${drillId}"]`);
                let noteFromInput = achievement.note; // Default value
                if (drillElement) {
                    const noteInputElement = drillElement.querySelector('.drill-note-input');
                    if (noteInputElement) {
                        noteFromInput = noteInputElement.value;
                    }
                }

                achievement.repetition = newReps; // Update local data
                achievement.note = noteFromInput; // Update local note data

                // Prepare for backend update
                drillsToUpdate[categoryId][drillId] = {repetition: newReps, note: achievement.note};
            }

            displayPlan(currentPlanTemplate, currentDailyPlanData); // Optimistic UI update

            // Now, call a function to save all these updates to the backend
            if (Object.keys(drillsToUpdate[categoryId]).length > 0) { // Check if there are drills to update in this category
                // The payload for saveMultipleDrillUpdates expects an object where keys are categoryId
                const payloadForBackend = {[categoryId]: drillsToUpdate[categoryId]};
                saveMultipleDrillUpdates(payloadForBackend);
            }
        }

        async function saveDrillUpdate(categoryId, drillId, newReps, note) {
            if (!isToday) {
                addMessageToChat("Modifications are only allowed for today's plan.", "system-info");
                return;
            }
            if (!ensureDailyPlanDataInitialized()) return;


            const payload = {
                repetitions: {
                    [categoryId]: {
                        [drillId]: {
                            repetition: newReps,
                            note: note || "" // Ensure note is always a string
                        }
                    }
                }
            };

            try {
                const response = await fetch(coachBackendURL + '/api/v1/daily-plans/today', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-User-Email': userEmail
                    },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to save drill update: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                const updatedPlanFromServer = await response.json();
                currentDailyPlanData = updatedPlanFromServer;
                displayPlan(currentPlanTemplate, currentDailyPlanData); // Re-render with authoritative data
                addMessageToChat("Plan updated successfully.", "system-success");

            } catch (error) {
                console.error('Error saving drill update:', error);
                addMessageToChat(`Error saving update: ${error.message}`, 'system-error');
            }
        }

        async function saveMultipleDrillUpdates(repetitionsPayload) {
            // repetitionsPayload is expected to be like: { categoryId1: { drillId1: {repetition: X, note: Y}, ... }, ... }
            if (!isToday || Object.keys(repetitionsPayload).length === 0) {
                if (Object.keys(repetitionsPayload).length === 0) console.log("No updates to send for category adjustment.");
                return;
            }
            if (!ensureDailyPlanDataInitialized()) return;


            const payload = {
                repetitions: repetitionsPayload
            };

            try {
                const response = await fetch(coachBackendURL + '/api/v1/daily-plans/today', {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json',
                        'X-User-Email': userEmail},
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Failed to save multiple drill updates: ${response.statusText} (${errorData.error || 'Unknown error'})`);
                }
                const updatedPlanFromServer = await response.json();
                currentDailyPlanData = updatedPlanFromServer;
                displayPlan(currentPlanTemplate, currentDailyPlanData);
                addMessageToChat("Category repetitions updated successfully.", "system-success");

            } catch (error) {
                console.error('Error saving multiple drill updates:', error);
                addMessageToChat(`Error saving category update: ${error.message}`, 'system-error');
            }
        }

        // Event listeners for date controls
        dateDisplay.addEventListener('click', () => {
            datePicker.style.display = 'block';
            datePicker.value = formatDate(currentDate);
            datePicker.focus();
        });

        datePicker.addEventListener('blur', () => {
            setTimeout(() => {
                if (document.activeElement !== datePicker) {
                    datePicker.style.display = 'none';
                }
            }, 100);
        });

        datePicker.addEventListener('change', () => {
            currentDate = new Date(datePicker.value + 'T00:00:00');
            datePicker.style.display = 'none';
            loadPlan();
        });

        prevDayButton.addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() - 1);
            loadPlan();
        });

        nextDayButton.addEventListener('click', () => {
            currentDate.setDate(currentDate.getDate() + 1);
            loadPlan();
        });

        // Initial load for training plan
        loadPlan();

        // --- Chat Pane JavaScript ---
        const chatHistory = document.getElementById('chat-history');
        const chatMessageInput = document.getElementById('chat-message-input');
        const chatSendButton = document.getElementById('chat-send-button');
        const chatMicButton = document.getElementById('chat-mic-button');
        const chatDeleteSessionButton = document.getElementById('chat-delete-session-button');
        const vuMeterLevel = document.getElementById('vu-meter-level'); // NEW: Get VU meter element
        const micGainSlider = document.getElementById('mic-gain-slider'); // NEW: Get mic gain slider

        let audioContext;
        let microphoneStream;
        let micGainNode; // NEW: GainNode for microphone input
        let workletNode;
        let audioStreamSocket; // WebSocket for audio
        let isStreaming = false;

        // --- Audio Playback Queue ---
        let audioQueue = [];
        let isAudioPlaying = false;
        let currentAudioSource = null; // NEW: To hold the currently playing source
        const AGENT_AUDIO_SAMPLE_RATE = 24000; // For audio coming FROM the agent

        // --- Audio Capture and Resampling ---
        const TARGET_SAMPLE_RATE = 16000; // For audio going TO the agent

        // The AudioWorklet is the modern way to process audio in a separate thread.
        const audioWorkletProcessor = `
            class AudioStreamerProcessor extends AudioWorkletProcessor {
                process(inputs, outputs, parameters) {
                    const inputData = inputs[0][0];
                    if (inputData) {
                        // Send the raw audio data (Float32Array) to the main thread.
                        this.port.postMessage(inputData);
                    }
                    return true; // Keep the processor running
                }
            }
            registerProcessor('audio-streamer-processor', AudioStreamerProcessor);
        `;
        const workletBlob = new Blob([audioWorkletProcessor], { type: 'application/javascript' });
        const workletURL = URL.createObjectURL(workletBlob);

        // --- Helper Functions ---

        /**
         * Updates the VU meter based on the audio data chunk.
         * @param {Float32Array | null} data The float audio data.
         */
        function updateVuMeter(data) {
            if (!data || data.length === 0) {
                vuMeterLevel.style.width = '0%';
                return;
            }
            let sumSquares = 0.0;
            for (const sample of data) {
                sumSquares += sample * sample;
            }
            const rms = Math.sqrt(sumSquares / data.length);
            // rms is between 0 and 1. Scale it for better visibility.
            const volume = Math.min(100, rms * 200); // Clamp at 100%
            vuMeterLevel.style.width = `${volume}%`;
        }


        /**
         * Converts a Float32Array of audio samples to a 16-bit PCM ArrayBuffer.
         * @param {Float32Array} input The float audio data (samples between -1.0 and 1.0).
         * @returns {ArrayBuffer} The 16-bit PCM audio data.
         */
        function floatTo16BitPCM(input) {
            const output = new DataView(new ArrayBuffer(input.length * 2));
            for (let i = 0; i < input.length; i++) {
                const s = Math.max(-1, Math.min(1, input[i]));
                // Convert to 16-bit integer
                const pcmSample = s < 0 ? s * 0x8000 : s * 0x7FFF;
                output.setInt16(i * 2, pcmSample, true); // true for little-endian
            }
            return output.buffer;
        }

        /**
         * Converts an ArrayBuffer to a base64 string.
         * @param {ArrayBuffer} buffer The buffer to convert.
         * @returns {string} The base64 encoded string.
         */
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        /**
         * Converts a base64 string to an ArrayBuffer.
         * @param {string} base64 The base64 string to convert.
         * @returns {ArrayBuffer} The decoded ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Converts a 16-bit PCM ArrayBuffer to a Float32Array.
         * @param {ArrayBuffer} arrayBuffer The 16-bit PCM audio data.
         * @returns {Float32Array} The float audio data for playback.
         */
        function pcm16ToFloat(arrayBuffer) {
            const int16Array = new Int16Array(arrayBuffer);
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0;
            }
            return float32Array;
        }

        // --- Audio Playback Queue Logic ---

        /**
         * NEW: Stops the current audio playback and clears the queue.
         */
        function stopAndClearAudioQueue() {
            console.log("Interrupting audio playback and clearing queue.");
            audioQueue = []; // Purge the queue
            if (currentAudioSource) {
                currentAudioSource.stop(); // This will trigger the onended event
            }
        }

        function playNextChunkInQueue() {
            if (audioQueue.length === 0) {
                isAudioPlaying = false;
                currentAudioSource = null;
                console.log("Audio queue finished or cleared.");
                return;
            }

            isAudioPlaying = true;
            const float32Audio = audioQueue.shift(); // Get the next chunk from the front of the queue

            if (!audioContext || audioContext.state !== 'running') {
                console.warn("AudioContext not running, cannot play audio. Re-queuing chunk.");
                audioQueue.unshift(float32Audio); // Put the chunk back at the front
                isAudioPlaying = false;
                return;
            }

            const audioBuffer = audioContext.createBuffer(
                1,
                float32Audio.length,
                AGENT_AUDIO_SAMPLE_RATE
            );
            audioBuffer.copyToChannel(float32Audio, 0);

            const source = audioContext.createBufferSource();
            currentAudioSource = source; // Store the new source
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            source.onended = playNextChunkInQueue; // The key to sequential playback
            source.start();
            console.log(`Playing audio chunk of ${float32Audio.length} samples. Queue size: ${audioQueue.length}`);
        }


        async function startStreaming() {
            if (isStreaming) return;

            audioQueue = [];
            isAudioPlaying = false;
            currentAudioSource = null;

            // 1. Initialize AudioContext and load our Worklet
            try {
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(`AudioContext created. Initial state: ${audioContext.state}, Sample rate: ${audioContext.sampleRate} Hz`);
                }

                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log(`AudioContext resumed. New state: ${audioContext.state}`);
                }

                await audioContext.audioWorklet.addModule(workletURL);
            } catch (e) {
                console.error("AudioContext/Worklet error:", e);
                addMessageToChat("The audio context could not be started.", "system-error");
                return;
            }

            // 2. Establish the WebSocket connection
            const wsURL = `${coachAgentURL.replace('http', 'ws')}/api/v1/chat/stream`;
            audioStreamSocket = new WebSocket(wsURL);

            audioStreamSocket.onopen = async () => {
                addMessageToChat("Streaming connection established.", "system-info");

                // 3. Once the WebSocket is open, request microphone access
                try {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            // Capture at the native sample rate for best quality before resampling
                            sampleRate: audioContext.sampleRate,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                        }
                    });

                    // NEW: Create GainNode and connect it
                    micGainNode = audioContext.createGain();
                    micGainNode.gain.value = parseFloat(micGainSlider.value); // Set initial gain from slider

                    // 4. Connect the microphone stream to our Worklet (via GainNode)
                    const source = audioContext.createMediaStreamSource(microphoneStream);
                    source.connect(micGainNode); // Connect source to gain node

                    workletNode = new AudioWorkletNode(audioContext, 'audio-streamer-processor');
                    micGainNode.connect(workletNode); // Connect gain node to worklet node

                    // --- CRITICAL CHANGE: Resample audio before sending ---
                    workletNode.port.onmessage = async (event) => {
                        if (audioStreamSocket && audioStreamSocket.readyState === WebSocket.OPEN) {
                            const inputFloat32Array = event.data;

                            // 1. Create a buffer with the original audio data
                            const originalBuffer = audioContext.createBuffer(1, inputFloat32Array.length, audioContext.sampleRate);
                            originalBuffer.copyToChannel(inputFloat32Array, 0);

                            // 2. Resample the audio to the target rate using OfflineAudioContext
                            const duration = originalBuffer.duration;
                            const offlineContext = new OfflineAudioContext(1, duration * TARGET_SAMPLE_RATE, TARGET_SAMPLE_RATE);
                            const bufferSource = offlineContext.createBufferSource();
                            bufferSource.buffer = originalBuffer;
                            bufferSource.connect(offlineContext.destination);
                            bufferSource.start();

                            const resampledBuffer = await offlineContext.startRendering();
                            const resampledData = resampledBuffer.getChannelData(0);

                            // 3. Convert the resampled audio to 16-bit PCM and send
                            const pcm16Buffer = floatTo16BitPCM(resampledData);
                            const base64Data = arrayBufferToBase64(pcm16Buffer);

                            const message = {
                                mime_type: "audio/pcm",
                                data: base64Data
                            };

                            updateVuMeter(inputFloat32Array); // Keep VU meter responsive with original data
                            audioStreamSocket.send(JSON.stringify(message));
                        }
                    };

                    isStreaming = true;
                    chatMicButton.classList.add('recording');
                    chatMicButton.title = "Stop streaming";

                } catch (err) {
                    addMessageToChat(`Microphone error: ${err.message}`, "system-error");
                    stopStreaming();
                }
            };

            // --- MODIFIED: Handle incoming messages, including interruption ---
            audioStreamSocket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    try {
                        const message = JSON.parse(event.data);

                        // Handle control messages first
                        if (message.interrupted) {
                            addMessageToChat("Agent interrupted.", "system-info");
                            stopAndClearAudioQueue(); // Stop audio and clear queue
                            return; // Stop processing this message further
                        }
                        if (message.turn_complete) {
                            addMessageToChat("Agent turn complete.", "system-info");
                            return;
                        }

                        // Handle data messages
                        if (message.mime_type === 'audio/pcm' && message.data) {
                            const pcm16Buffer = base64ToArrayBuffer(message.data);
                            const float32Audio = pcm16ToFloat(pcm16Buffer);

                            if (float32Audio.length > 0 && !float32Audio.every(s => s === 0)) {
                                audioQueue.push(float32Audio);
                                if (!isAudioPlaying) {
                                    playNextChunkInQueue();
                                }
                            }
                        } else if (message.mime_type === 'text/plain' && message.data) {
                            addMessageToChat(message.data, 'agent');
                        } else {
                            console.log("Unknown message format received:", message);
                        }
                    } catch (e) {
                        console.error("Error processing received message:", e, "Data:", event.data);
                    }
                }
            };

            audioStreamSocket.onclose = (event) => {
                let reason = event.reason || "Connection terminated.";
                addMessageToChat(`Streaming stopped: ${reason}`, "system-info");
                stopStreaming();
            };

            audioStreamSocket.onerror = (error) => {
                addMessageToChat("Streaming connection error.", "system-error");
                console.error("WebSocket error:", error);
                stopStreaming();
            };
        }

        function stopStreaming() {
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
            }
            if (workletNode) {
                workletNode.port.close();
                workletNode.disconnect();
                workletNode = null;
            }
            // NEW: Disconnect and nullify micGainNode
            if (micGainNode) {
                micGainNode.disconnect();
                micGainNode = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.close();
                audioContext = null;
            }
            if (audioStreamSocket) {
                audioStreamSocket.close();
                audioStreamSocket = null;
            }

            stopAndClearAudioQueue(); // Ensure audio is stopped and queue is cleared

            isStreaming = false;
            chatMicButton.classList.remove('recording');
            chatMicButton.title = "Start streaming";
            chatMessageInput.disabled = false;
            chatSendButton.disabled = false;
            updateVuMeter(null);
        }

        // Event listener for the microphone button
        chatMicButton.addEventListener('click', () => {
            if (isStreaming) {
                stopStreaming();
            } else {
                startStreaming();
            }
        });

        // NEW: Event listener for mic gain slider
        micGainSlider.addEventListener('input', () => {
            if (micGainNode) {
                micGainNode.gain.value = parseFloat(micGainSlider.value);
                console.log(`Microphone gain set to: ${micGainNode.gain.value}`);
            }
        });

        // Function to send text messages
        function sendMessage() {
            const messageText = chatMessageInput.value.trim();
            if (messageText === '') {
                return;
            }

            if (!audioStreamSocket || audioStreamSocket.readyState !== WebSocket.OPEN) {
                addMessageToChat("WebSocket connection not established. Please start streaming (click mic button) first.", "system-error");
                console.error("WebSocket not open. Cannot send text message.");
                return;
            }

            const message = {
                mime_type: "text/plain",
                data: messageText
            };

            try {
                audioStreamSocket.send(JSON.stringify(message));
                addMessageToChat(messageText, 'user');
                chatMessageInput.value = '';
            } catch (e) {
                console.error("Error sending text message:", e);
                addMessageToChat("Error sending message. Please try again.", "system-error");
            }
        }

        // Event listeners for text input and send button
        chatSendButton.addEventListener('click', sendMessage);
        chatMessageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });


        // Simplified function to add messages to the chat history
        function addMessageToChat(text, type = 'user') {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message', type);

            if (type === 'system-error') messageElement.style.color = 'red';
            if (type === 'system-success') messageElement.style.color = 'green';
            if (type === 'system-info') messageElement.style.color = 'blue';

            messageElement.textContent = text;
            chatHistory.appendChild(messageElement);
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        chatDeleteSessionButton.addEventListener('click', () => {
            if (!confirm("Are you sure you want to delete the session and clear chat history?")) {
                return;
            }

            fetch(coachAgentURL + '/api/v1/chat', {
                method: 'DELETE',
            })
                .then(response => {
                    if (response.ok) {
                        chatHistory.innerHTML = '';
                        addMessageToChat("Session and history cleared.", 'system-info');
                        console.log("Chat session deleted successfully.");
                    } else {
                        response.text().then(text => {
                            addMessageToChat(`Error deleting session: ${response.status} ${text || ''}`, 'system-error');
                            console.error('Error deleting session:', response.status, text);
                        });
                    }
                })
                .catch(error => {
                    addMessageToChat("Network error while deleting session.", 'system-error');
                    console.error('Network error deleting session:', error);
                });
        });

        const userEmail = "guillaume.blaquiere@gmail.com"
        let ws;

        function connectWebSocket() {
            // Build the WebSocket URL
            const wsURL = `${coachBackendURL.replace('http', 'ws')}/api/v1/ws?email=${encodeURIComponent(userEmail)}`;
            console.log("Connecting to WebSocket:", wsURL);

            ws = new WebSocket(wsURL);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                addMessageToChat("Real-time connection active.", "system-success");
            };

            ws.onmessage = (event) => {
                console.log("WebSocket message received:", event.data);
                try {
                    const message = JSON.parse(event.data);

                    if (message.action === 'PLAN_UPDATED') {
                        addMessageToChat("Your plan has been updated in real-time!", "system-info");

                        currentDailyPlanData = message.data;

                        if (currentPlanTemplate) {
                            displayPlan(currentPlanTemplate, currentDailyPlanData);
                        }
                    }
                } catch (error) {
                    console.error("Error parsing WebSocket message:", error);
                }
            };

            ws.onclose = (event) => {
                console.log("WebSocket connection closed.", event);
                addMessageToChat("Real-time connection lost. Attempting to reconnect...", "system-error");
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                addMessageToChat("A real-time connection error occurred.", "system-error");
            };
        }
        connectWebSocket()
    })
    // End of DOMContentLoaded
</script>
</body>
</html>